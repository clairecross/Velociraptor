---
title: "VR-Claw on the RAPID Dataset"
author: "Claire Cross"
date: "05-20-2024"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# # uncomment lines below to install packages
# if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
# #install.packages("devtools", repos = "http://cran.us.r-project.org")
# BiocManager::install("cytoMEM")
# install.packages("tidyverse", repos = "http://cran.us.r-project.org")
# install.packages("dplyr", repos = "http://cran.us.r-project.org")
# #install.packages("ggpubr", repos = "http://cran.us.r-project.org")
# BiocManager::install("flowCore")
# BiocManager::install("Biobase")
# install.packages("survival", repos = "http://cran.us.r-project.org")
# install.packages("survminer", repos = "http://cran.us.r-project.org")
# #install.packages("plyr", repos = "http://cran.us.r-project.org")
# install.packages("cowplot", repos = "http://cran.us.r-project.org")
# install.packages("RColorBrewer", repos = "http://cran.us.r-project.org")
# install.packages("FNN", repos = "http://cran.us.r-project.org")
# install.packages("fancycut", repos = "http://cran.us.r-project.org")
# install.packages("dbscan", repos = "http://cran.us.r-project.org")
# install.packages("ggplot2", repos = "http://cran.us.r-project.org")
``` 

```{r initialization}
#load packages into the working library
suppressPackageStartupMessages({#library(devtools)
                                library(cytoMEM)
                                library(tidyverse)
                                library(dplyr)
                                #library(ggpubr)
                                library(flowCore)
                                library(Biobase)
                                library(survival)
                                library(survminer)
                                #library(plyr)
                                library(cowplot)
                                library(RColorBrewer)
                                library(FNN)
                                library(fancycut)
                                library(dbscan)
                                library(ggplot2)})
source('./R/tSNE_plots.R')
source('./R/VR-Claw_plots.R')
source('./R/VR-Claw_functions.R')
source('./R/tatarize_color_palette.R')

#specify fcs file location and output path
file.path <- './data files/RAPID - Leelatian and Sinnaeve et al/'
output.path <- './output files/VR-Claw_RAPID/'

#locate fcs file
fcs.files <- dir(path = file.path, pattern = "*.fcs")
print(fcs.files)
```

```{r load data}
#load cell data
setwd(file.path)
data.list <- lapply(lapply(fcs.files, read.FCS, truncate_max_range = FALSE), exprs)
combined.patient.data <- as.data.frame(do.call(rbind, mapply(cbind, data.list, "File_ID"= c(1:length(data.list)), SIMPLIFY=F)))
colnames(combined.patient.data)[1:(ncol(combined.patient.data)-1)] <- as.character(read.FCS(fcs.files[1], truncate_max_range=FALSE)@parameters@data[["desc"]])
colnames(combined.patient.data)

#store number of cells per file
sample_num <- nrow(combined.patient.data[which(combined.patient.data$File_ID == 1),]) #assumes equal number of cells in every file 

#load clinical data
OS.data.files <-  dir(pattern="*.csv")
OS.data <- read.csv(OS.data.files)
```

```{r select data}
#arcsinh transformation
cofactor <- 5
transformed.data <- combined.patient.data %>% select(-contains('File_ID')) %>% 
                    select(-contains('tSNE')) %>% mutate_all(function(x) asinh(x/cofactor))

#choose markers to use downstream for MEM calculations
chosen.markers <- transformed.data %>% select(contains('(v2)') | contains('CycinB1'))

#select tsne indices
tsne.data <- combined.patient.data[46:47]
colnames(tsne.data) <- c('tSNE1', 'tSNE2')
```

```{r t-SNE plots}
#plot tSNE axes
tsne.plot <- ggplot(tsne.data) + geom_point(aes(x=tSNE2, y=tSNE1), color='lightgrey') +
              labs(x='t-SNE2', y='t-SNE1', title='RAPID GBM Cohort', 
                   caption="Data from Leelatian & Sinnaeve et al., eLife. 2020") + 
              coord_fixed(ratio=1) + theme_bw() + theme(panel.grid = element_blank())
print(tsne.plot)

#plot cell density on t-SNE axes
tsne.dens.plot <- tsne_density(tsne.data, export=TRUE, output_path=output.path)

#plot heat on markers
tsne.heat.on.markers <- tsne_heat_on_markers(tsne.data, chosen.markers, n_col=5, export=TRUE, output_path=output.path)
```

```{r set VR-Claw constants}
#choose clinical data for VR-Claw
clinical_col <- 3 #OS Time
status_col <- 4 #OS Status

#define color palette
col.palette <- c("p>0.1" ="lightgray" ,
                 "p<0.01 HR>1" = "darkred",
                 "p<0.05 HR>1" = "red",
                 "p<0.1 HR>1" = "darkgray",
                 "p<0.01 HR<1" = "darkblue",
                 "p<0.05 HR<1" = "blue",
                 "p<0.1 HR<1"= "darkgray")

#k-value for k-nearest neighbors 
kval <- floor(sqrt(nrow(tsne.data)))

#filtering variables
min.patients.per.cluster <- 1
min.cells.per.cluster <- 25
pval.cutoff <- 0.05
```

```{r VR-Claw}
start_time <- Sys.time()

#get KNN indices for each cell
neighbor.index <- knnx.index(tsne.data, tsne.data, k=kval)

#add File_ID data to KNN indices  
cluster_and_patient_df <- as.data.frame(cbind(neighbor.index, combined.patient.data$File_ID))
colnames(cluster_and_patient_df)[ncol(cluster_and_patient_df)] <- 'File_ID'
  
#determine which cells belong to which patient (based on sample number)
patient_list <- list()
for (i in 1:length(unique(cluster_and_patient_df$File_ID))){
  patient_list[[i]] <- seq(((i-1)*sample_num + 1), i*sample_num)
  if (i==1){ #first patient should include the lower bound in the interval
    cell.index.intervals <- paste0('[', ((i-1)*sample_num + 1), ',', i*sample_num, ']')
  }else{
    cell.index.intervals <- c(cell.index.intervals, paste0('(', ((i-1)*sample_num + 1), ',', i*sample_num, ']'))
  }
}
  
  

  # #find neighborhood abundances for each patient
  # all.subset.abundances <- as.data.frame(matrix(ncol=length(patient_list),            #col=patient
  #                                               nrow=nrow(cluster_and_patient_df))) #row=neighborhood
  # #for each neighborhood, determine the percentage of each patient's cells that are in that neighborhood, and that neighborhood's IQR
  # num.patients <- c()
  # abundance.IQR <- list()
  # abundance.groups <- list() #list of neighborhoods; each element has length = number of patients
  # cox.summary<- list()
  # high.low.groups <- list()
  # low.median <- vector()
  # high.median <- vector()


  # #FUNCTIONS
  # calc_nbh_percent <- function(pl, cp_df_r){ #pass in patient_list and a row of cluster_and_patient_df
  #   cp_df_r <- as.data.frame(t(cp_df_r)) #reset data type to row in a dataframe
  #   #for each patient, what percentage of their cells are in this neighborhood?
  #   length(cp_df_r[1:kval][,which(cp_df_r[1:kval] %in% pl)])*100/sample_num
  # 
  # }
  # 
  # #how many patients are in a neighborhood
  # calc_num_patients <- function(cp_df){num.patients <- length(unique(wafflecut(cp_df,
  #                                                       intervals=cell.index.intervals)))}
  # 
  # #is a neighborhood prognostic?
  # nbh_analysis <- function(cp_df){
  #   #what is each patient's cell abundance for this particular neighborhood
  #   nbh_percent <- sapply(patient_list, calc_nbh_percent, cp_df)
  #   
  #   #what is that neighborhood's IQR (75th percentile - 25th percentile)
  #   abundance.IQR = IQR(nbh_percent) 
  # 
  #   #divide patients into high and low groups based on subset abundance and test for enrichment
  #   abundance.groups <- ifelse(nbh_percent > abundance.IQR, 1, 0) # 1 = high, 0 = low
  # 
  #   #Cox proportional hazards model
  #   Group <- factor(abundance.groups, levels = c(0,1), labels = c("Low", "High"))
  #   group.survival.data <- cbind(OS.data, Group)
  #   high.low.groups <- split(group.survival.data, group.survival.data$Group)
  #   low.median <- median(high.low.groups[["Low"]][[clinical_col]])
  #   high.median <- median(high.low.groups[["High"]][[clinical_col]])
  #   coxph.model <- coxph(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, 
  #                        data=group.survival.data)
  #   summary(coxph.model)
  # }
  
#calculate the number of patients present in each neighborhood
num.patients <- apply(cluster_and_patient_df, 1, calc_num_patients)

#calculate survival statistics for each neighborhood
cox.summary <- apply(cluster_and_patient_df, 1, nbh_analysis)
  
#export neighborhood data
save(num.patients, file=paste0(output.path, 'num patients.RData'))
save(cox.summary, file=paste0(output.path, 'cox summary.RData'))
  
#calculate time elapsed
total_time <- Sys.time() - start_time
time_diff <- paste(total_time, attr(total_time, 'units')) 
print(time_diff)
write.table(time_diff, file=paste0(output.path, 'VR-Claw time elapsed.txt'))
```

```{r results}
start_time <- Sys.time()

#create output folders
dir.create(paste0(output.path, '/unfiltered'))
dir.create(paste0(output.path, '/filtered'))

# #load neighborhood survival data
# load(paste0(output.path, 'cox summary.RData'))
# load(paste0(output.path, 'num patients.RData'))

#original VR-Claw Plot
  #set significance status for each cell
  plotting.data <- data.frame(tSNE2=tsne.data[,2], 
                              tSNE1=tsne.data[,1], 
                              cluster=c(1:nrow(tsne.data)), 
                              num.neighborhood.patients=num.patients, 
                              status="p>0.1")
  survival_stats <- cox.summary
  
  for (z in 1:length(survival_stats)){
    survival_stats[[z]] = cox.summary[[z]]$coefficients
    #each neighborhood must have the minimum number of patients per cluster to be significant
    if (plotting.data$num.neighborhood.patients[z] >= min.patients.per.cluster){
      if (survival_stats[[z]][,c(5)] <= 0.01 & survival_stats[[z]][,c(2)] <= 1){ #p<0.01, HR<1
        plotting.data$status[z] <- "p<0.01 HR<1"
      }
      else if (survival_stats[[z]][,c(5)] <= 0.05 & survival_stats[[z]][,c(2)] <= 1){ #p<0.05, HR<1
        plotting.data$status[z] <- "p<0.05 HR<1"
      }
      else if (survival_stats[[z]][,c(5)] <= 0.1 & survival_stats[[z]][,c(2)] <= 1){ #p<0.1 HR<1
        plotting.data$status[z] <- "p<0.1 HR<1"
      }
      if (survival_stats[[z]][,c(5)] <= 0.01 & survival_stats[[z]][,c(2)] >= 1){ #p<0.01 HR>1
        plotting.data$status[z] <- "p<0.01 HR>1"
      }
      else if (survival_stats[[z]][,c(5)] <= 0.05 & survival_stats[[z]][,c(2)] >= 1){ #p<0.05 HR>1
        plotting.data$status[z] <- "p<0.05 HR>1"
      }
      else if (survival_stats[[z]][,c(5)] <= 0.1 & survival_stats[[z]][,c(2)] >= 1){ #p<0.1 HR>1
        plotting.data$status[z] <- "p<0.1 HR>1"
      }
    }
  }
    
  #get maximum x and y values to set the scales
  max_x = max(c(max(plotting.data$tSNE2),abs(min(plotting.data$tSNE2))))
  max_y = max(c(max(plotting.data$tSNE1),abs(min(plotting.data$tSNE1))))
    
  #reorder data so the significant cells are displayed on top
  light.grey.cells <- plotting.data[which(plotting.data$status=="p>0.1"),]
  dark.grey.cells <- plotting.data[which(plotting.data$status=="p<0.1 HR>1" | plotting.data$status=="p<0.1 HR<1"),]
  light.red.cells <- plotting.data[which(plotting.data$status=="p<0.05 HR>1"),]
  dark.red.cells <- plotting.data[which(plotting.data$status=="p<0.01 HR>1"),]
  light.blue.cells <- plotting.data[which(plotting.data$status=="p<0.05 HR<1"),]
  dark.blue.cells <- plotting.data[which(plotting.data$status=="p<0.01 HR<1"),]
  to.plot <- rbind(light.grey.cells, dark.grey.cells, 
                   light.red.cells, light.blue.cells,
                   dark.red.cells, dark.blue.cells)
  
  #plot
  VRPTR_plot <- ggplot(to.plot) + geom_point(aes(x=to.plot[,1], y=to.plot[,2], 
                                                 col = as.factor(to.plot$status))) + 
                        scale_color_manual(values = col.palette) + 
                        guides(colour = guide_legend(override.aes = list(size=5))) + 
                        theme_bw() + theme(panel.grid.major = element_blank(), 
                                           panel.grid.minor = element_blank()) + 
                        labs(color = "Prognostic Subsets", x = "t-SNE2", y = "t-SNE1", 
                             title = paste("VRPTR Prognostic Populations - pre-filtering, k=", kval)) +
                        ylim(-max_y,max_y) +xlim(-max_x,max_x) + coord_fixed(ratio = 1)
  VRPTR_plot

  #export
  png(paste0(output.path, '/unfiltered/', strftime(Sys.time(), "%Y-%m-%d"), " original_VRPTR_plot.png"),
      res = 200, width = 1500, height = 1500)
  print(VRPTR_plot)
  dev.off()
```

```{r}
  #get significance data
  marker.tsne.data <- cbind(combined.patient.data[,c(1:43, 48)], tsne.data)
  all.data <- left_join(marker.tsne.data, plotting.data[,c(1,2,4,5)]) #add to cell data
  
  #DBSCAN clustering 
  #p<0.01 
  #filter for significant cells
  regions.of.interest.01 <- all.data %>% dplyr::filter(status == "p<0.01 HR<1" | #dark blue
                                                       status == "p<0.01 HR>1" ) #dark red
  regions.of.interest.embedding.01 <- cbind(regions.of.interest.01$tSNE1,
                                            regions.of.interest.01$tSNE2)
  
  #dbscan
  dbscan.results <- dbscan::dbscan(regions.of.interest.embedding.01, eps = 4, minPts = 1)
  regions.of.interest.01$cluster <- dbscan.results$cluster
  
  #remove noise cluster 0
  regions.of.interest.01 <- regions.of.interest.01[which(regions.of.interest.01$cluster!=0),]
  n.clusters <- length(unique(regions.of.interest.01$cluster)) #get number of clusters
  
  #rename clusters to include significance stats
  regions.of.interest.01$cluster <- paste0(regions.of.interest.01$cluster,"01")
  regions.of.interest.01$cluster <-as.numeric(regions.of.interest.01$cluster)
  
  #DBSCAN plot
  dbscan_plot_01 <- ggplot(data.frame(x = regions.of.interest.01$tSNE2, y = regions.of.interest.01$tSNE1,
                                     col = as.factor(regions.of.interest.01$cluster))) +
                    geom_point(aes(x=x, y=y, color=col),cex = 1.5) +
                    guides(colour = guide_legend(override.aes = list(size=5), nrow = 13)) +
                    labs(x = "tSNE2", y = "tSNE1",title = "DBSCAN Clusters (p<0.01)",
                         color = "DBSCAN Cluster") +
                    theme_bw() + theme(legend.title = element_blank(), panel.grid = element_blank()) + 
                    scale_color_manual(values = tatarize_optimized(n.clusters)) +
                    xlim(-100, 100) + ylim(-100, 100) + coord_fixed(ratio=1)
  # dbscan_plot
  #export
  png(paste0(output.path, '/unfiltered/', strftime(Sys.time(),"%Y-%m-%d"), " DBSCAN_p0.01_plot.png"),
    res = 200, width = 2000, height = 2000)
  print(dbscan_plot_01)
  dev.off()
  
  #p<0.05
  #filter for significant cells
  regions.of.interest.05 <- all.data %>% dplyr::filter(status == "p<0.05 HR<1" | #dark blue
                                                       status == "p<0.05 HR>1" ) #dark red
  regions.of.interest.embedding.05 <- cbind(regions.of.interest.05$tSNE1,
                                            regions.of.interest.05$tSNE2)
  
  #dbscan
  dbscan.results <- dbscan::dbscan(regions.of.interest.embedding.05, eps = 4, minPts = 1)
  regions.of.interest.05$cluster <- dbscan.results$cluster
  
  #remove noise cluster 0
  regions.of.interest.05 <- regions.of.interest.05[which(regions.of.interest.05$cluster!=0),]
  n.clusters <- length(unique(regions.of.interest.05$cluster)) #get number of clusters
  
  #rename clusters to include significance stats
  regions.of.interest.05$cluster <- paste0(regions.of.interest.05$cluster,"05")
  regions.of.interest.05$cluster <-as.numeric(regions.of.interest.05$cluster)
  
  #DBSCAN plot
  dbscan_plot_05 <- ggplot(data.frame(x = regions.of.interest.05$tSNE2, y = regions.of.interest.05$tSNE1,
                                    col = as.factor(regions.of.interest.05$cluster))) +
                    geom_point(aes(x=x, y=y, color=col),cex = 1.5) +
                    guides(colour = guide_legend(override.aes = list(size=5), nrow = 13)) +
                    labs(x = "tSNE2", y = "tSNE1",title = "DBSCAN Clusters (p<0.05)",
                         color = "DBSCAN Cluster") +
                    theme_bw() + theme(legend.title = element_blank(), panel.grid = element_blank()) + 
                    scale_color_manual(values = tatarize_optimized(n.clusters)) +
                    xlim(-100, 100) + ylim(-100, 100) + coord_fixed(ratio=1)
  # dbscan_plot
  #export
  png(paste0(output.path, '/unfiltered/', strftime(Sys.time(),"%Y-%m-%d"), " DBSCAN_p0.05_plot.png"),
    res = 200, width = 2000, height = 2000)
  print(dbscan_plot_05)
  dev.off()
  
  
  #integrate and save data
  #combine all cluster data into one df
  combined.clusters <- rbind(regions.of.interest.05, regions.of.interest.01) 
  n.clusters <- length(unique(combined.clusters$cluster))
  
  #combined DBSCAN plot
  dbscan_plot <- ggplot(data.frame(x = combined.clusters$tSNE2, y = combined.clusters$tSNE1,
                                   col = as.factor(combined.clusters$cluster))) +
                   geom_point(aes(x=x, y=y, color=col),cex = 1.5) +
                  guides(colour = guide_legend(override.aes = list(size=5), nrow = 13)) +
                  labs(x = "tSNE2", y = "tSNE1", color = "DBSCAN Cluster", 
                       title = paste("Combined DBSCAN Clusters, k=", kval)) +
                  theme_bw() + theme(legend.title = element_blank(), panel.grid = element_blank()) + 
                  scale_color_manual(values = tatarize_optimized(n.clusters)) +
                  xlim(-100, 100) + ylim(-100, 100) + coord_fixed(ratio=1)
  # dbscan_plot
  #export
  png(paste0(output.path, '/unfiltered/', strftime(Sys.time(),"%Y-%m-%d"), " DBSCAN_combined_plot.png"),
    res = 200, width = 2000, height = 2000)
  print(dbscan_plot)
  dev.off()
  
  
  #add clusters, num.patients.per.cluster, and status to all.data
  all.data <- left_join(all.data, combined.clusters) 
  all.data[is.na(all.data)] <- 0 #replace cluster NAs with 0s
  
  
  
  #survival plots
  #split by patient ID
  all.data$cluster <- as.factor(all.data$cluster)
  patient.subsets <- split(all.data, all.data$File_ID)
  
  #calculate the percentage of each patient's cells in each cluster - make sure the cluster column is a factor!!!
  subset.abundance <- list()
  for (p in 1:length(patient.subsets)){ #looping over p = patients
    subset.abundance[[p]] = (summary(patient.subsets[[p]][,'cluster']))*100/nrow(patient.subsets[[p]]) #cell abundance in each cluster
  }
  all.subset.abundances = ldply(subset.abundance,rbind)  #dataframe of patient cell abundance in each cluster
  all.subset.abundances[is.na(all.subset.abundances)]<-0 
  
  #split patients into HIGH/LOW for each cluster by comparing to the cluster's abundance IQR value
  single.subset.abundance.data <- list()
  abundance.groups <- list()
  for(c in 1:ncol(all.subset.abundances)){ # looping over c = cluster
    abundance.IQR <- IQR(all.subset.abundances[,c]) #cluster's abundance IQR value
    abundance.groups[[c]] <- (all.subset.abundances[,c]>abundance.IQR) #TRUE=abundance greater than the IQR
    abundance.groups[[c]][abundance.groups[[c]]==TRUE] = 1 # 1 = high, 0 = low
  }             
  
  #Cox proportional hazards model
  cox.cluster.summary<- list()
  for (s in 1:ncol(all.subset.abundances)){ #looping over s = cluster
    Group <- factor(abundance.groups[[s]], levels = c(0,1), labels = c("Low", "High"))
    group.survival.data <- cbind(OS.data, Group)
    coxph.cluster.model <- coxph(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=group.survival.data)
    cox.cluster.summary[[colnames(all.subset.abundances)[s]]] <- summary(coxph.cluster.model)
  }
  #export
  write.csv(all.subset.abundances,paste(output.path, '/unfiltered/', 
                                        strftime(Sys.time(),"%Y-%m-%d"),
                                        " original_cluster_subset_abundances.csv",sep =""))
  
  #plotting info
  survival.plots <- list()
  final.prog.clusters <- c()
  pval.list <- c()
  HR.list <- c()
  for (s in 2:ncol(all.subset.abundances)){ #start at 2 to exclude non VR clusters
    if (colnames(all.subset.abundances)[s]!="(Other)"){
      cox.cluster.coefficients = cox.cluster.summary[[s]]$coefficients
      CI = cox.cluster.summary[[s]]$conf.int
      Group = factor(abundance.groups[[s]], levels = c(0,1), labels = c("Low", "High"))
      group.survival.data = cbind(OS.data, Group)
      coxph.model <- survfit(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=group.survival.data)
      #display cluster stats
      cluster.title <- paste0("Subset #", colnames(all.subset.abundances)[s], " (p = ", 
                              round(cox.cluster.coefficients[,5],3), ", HR = ",
                              round(cox.cluster.coefficients[,2],3), ", CI[",
                              round(CI[,3],3),",",round(CI[,4],3),"])")
      pval.list <- c(pval.list, cox.cluster.summary[[s]][["coefficients"]][,5])
      HR.list <- c(HR.list, cox.cluster.summary[[s]][["coefficients"]][,2])
      #plot significant clusters
      if (cox.cluster.coefficients[,5] <= pval.cutoff){
        final.prog.clusters <- c(final.prog.clusters, colnames(all.subset.abundances)[s])
      }
      survival.plots[[s]] <- ggsurvplot(coxph.model, 
                                        data=group.survival.data, 
                                        conf.int=F, 
                                        pval=F, 
                                        risk.table=T, 
                                        tables.y.text = FALSE, 
                                        legend.labs = c("Low", "High"), 
                                        legend.title = "Group",
                                        censor.shape=124,
                                        title = cluster.title)
    }
  }
  # survival.plots
  
  #export
  ggexport(survival.plots, filename = paste0(output.path, '/unfiltered/',
           strftime(Sys.time(),"%Y-%m-%d"), " survival plots_k=", i,".pdf"), 
           width = 7.2, height = 5.4)
  
  #calculate cluster stats
  #count cells per cluster from dbscan
  all.clusters <- split(combined.clusters, as.factor(combined.clusters$cluster))
  cluster.stats  <- as.data.frame(sapply(all.clusters, NROW))
  colnames(cluster.stats)<- "total_counts"
  
  #add survival stats
  cluster.stats$pval <- pval.list
  cluster.stats$HR <- HR.list
  
  #export
  write.csv(cluster.stats,paste(output.path, '/unfiltered/', strftime(Sys.time(),"%Y-%m-%d"), " original_DBSCAN_cluster_counts_and_stats.csv",sep =""))
  # print(cluster.stats)
  
  #patient level survival plots
  #GNP
  #calculate GNP status
  GNP.clusters <- all.subset.abundances[,as.character(unique(combined.clusters[which(combined.clusters$status=="p<0.01 HR>1" | combined.clusters$status=="p<0.05 HR>1"),'cluster']))]
  rownames(GNP.clusters) <- OS.data$Patient.ID
  GNP.clusters$sum <- rowSums(GNP.clusters)
  GNP.abundance.IQR <- IQR(GNP.clusters$sum)
  GNP.clusters$group <- ifelse(GNP.clusters$sum>=GNP.abundance.IQR, -1, 0)
  Group <- factor(GNP.clusters$group, levels = c(-1, 0), labels = c("GNP-High", "GNP-Low"))
  factored.data <- cbind(OS.data, Group) #select OS Time, OS Status and Group
  
  #calculate cox proportional hazards model 
  model.to.plot <- survfit(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=factored.data) #graphing data
  model.for.stats <- coxph(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=factored.data) #Cox PH Model
  model.stats <- summary(model.for.stats) #summarize cox ph
  
  #access interesting stats from Cox PH Model
  pval <- round(model.stats[["coefficients"]][,'Pr(>|z|)'], 3)
  HR <- round(1/model.stats[["coefficients"]][,'exp(coef)'], 3)
  CI <- paste0('[', round(1/model.stats[["conf.int"]][,4], 2), ',', 
               round(1/model.stats[["conf.int"]][,3], 2), ']')
  
  #plot
  GNP.plot <- ggsurvplot(model.to.plot, data=factored.data, risk.table=T,
                         legend.labs = c("GNP-high", "GNP-Low"), legend.title = "Group",
                         censor.shape=124, palette=c('darkred','black'))
  GNP.plot$plot <- GNP.plot$plot + annotate("text", x=Inf, y=Inf, vjust=1, hjust=1, size=5,
                                            label=paste0('p-value = ', pval, '
                                                         HR = ', HR, '
                                                         95% CI ', CI)) #annotate with stats
  # GNP.plot

  #export
  png(paste0(output.path, '/unfiltered/', strftime(Sys.time(),"%Y-%m-%d"), ' original_GNP survival plot.png'), height=1000, width=1000, res=200)
  print(GNP.plot)
  dev.off()
  write.csv(GNP.clusters, paste0(output.path, '/unfiltered/', strftime(Sys.time(),"%Y-%m-%d"), ' original GNP Classification.csv'))
  
  #GPP
  #calculate GPP status
  GPP.clusters <- all.subset.abundances[,as.character(unique(combined.clusters[which(combined.clusters$status=="p<0.01 HR<1" | combined.clusters$status=="p<0.05 HR<1"),'cluster']))]
  rownames(GPP.clusters) <- OS.data$Patient.ID
  GPP.clusters$sum <- rowSums(GPP.clusters)
  GPP.abundance.IQR <- IQR(GPP.clusters$sum)
  GPP.clusters$group <- ifelse(GPP.clusters$sum>=GPP.abundance.IQR, 1, 0)
  Group <- factor(GPP.clusters$group, levels = c(0, 1), labels = c("GPP-Low", "GPP-High"))
  factored.data <- cbind(OS.data, Group) #select OS Time, OS Status and Group
  
  #calculate cox proportional hazards model 
  model.to.plot <- survfit(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=factored.data) #graphing data
  model.for.stats <- coxph(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=factored.data) #Cox PH Model
  model.stats <- summary(model.for.stats) #summarize cox ph
  
  #access interesting stats from Cox PH Model
  pval <- round(model.stats[["coefficients"]][,'Pr(>|z|)'], 3)
  HR <- round(model.stats[["coefficients"]][,'exp(coef)'], 3)
  CI <- paste0('[', round(model.stats[["conf.int"]][,3], 2), ',', 
               round(model.stats[["conf.int"]][,4], 2), ']')
  
  #plot
  GPP.plot <- ggsurvplot(model.to.plot, data=factored.data, risk.table=T,
                         legend.labs = c("GPP-Low", "GPP-High"), legend.title = "Group",
                         censor.shape=124, palette=c('black','darkblue'))
  GPP.plot$plot <- GPP.plot$plot + annotate("text", x=Inf, y=Inf, vjust=1, hjust=1, size=5,
                                            label=paste0('p-value = ', pval, '
                                                         HR = ', HR, '
                                                         95% CI ', CI)) #annotate with stats
  # GPP.plot

  #export
  png(paste0(output.path, '/unfiltered/', strftime(Sys.time(),"%Y-%m-%d"), ' original_GPP survival plot.png'), height=1000, width=1000, res=200)
  print(GPP.plot)
  dev.off()
  write.csv(GPP.clusters, paste0(output.path, '/unfiltered/', strftime(Sys.time(),"%Y-%m-%d"), ' original GPP Classification.csv'))
  
  
  #FILTERING
  combined.clusters <- combined.clusters[which(combined.clusters$cluster %in% final.prog.clusters),]
  #filter out clusters with too few cells
  #count cells per cluster
  all.clusters <- split(combined.clusters, as.factor(combined.clusters$cluster))
  cluster.stats  <- as.data.frame(sapply(all.clusters, NROW))
  
  #remove any clusters that have fewer than the minimum number of cells
  suitable.cluster.list <- c()
  for (r in 1:nrow(cluster.stats)){ #loop through rows (clusters)
    if (cluster.stats[r,1] >= min.cells.per.cluster){ #check if cluster has at least minimum cells
      suitable.cluster.list <- c(suitable.cluster.list, rownames(cluster.stats)[r])
    }
  }
  #refined clusters meet the minimum cell number requirement
  refined.clusters <- combined.clusters[which(combined.clusters$cluster %in% suitable.cluster.list),]
  
  #integrate with other data
  all.data <- left_join(all.data[,1:48], refined.clusters) 
  all.data[is.na(all.data)] <- 0 #replace cluster NAs with 0s
  
  
  
  #filtered VRPTR plot
  #remove clusters that are no longer significant (set cluster number to 0)
  filtered.data <- all.data
  filtered.data[which(!(filtered.data$cluster %in% final.prog.clusters)), 'cluster'] <- 0
  filtered.data[which(filtered.data$cluster == 0), 'status'] <- 'p>0.1'
  
  #plot
  filtered.plotting.data <- data.frame(tSNE2=filtered.data$tSNE2, 
                                       tSNE1=filtered.data$tSNE1, 
                                       cluster=filtered.data$cluster, 
                                       status=filtered.data$status)
  
  #get maximum x and y values to set the scales
  max_x = max(c(max(filtered.plotting.data$tSNE2),abs(min(filtered.plotting.data$tSNE2))))
  max_y = max(c(max(filtered.plotting.data$tSNE1),abs(min(filtered.plotting.data$tSNE1))))
  
  #reorder data so the significant cells are displayed on top
  light.grey.cells <- filtered.plotting.data[which(filtered.plotting.data$status=="p>0.1"),]
  dark.grey.cells <- filtered.plotting.data[which(filtered.plotting.data$status=="p<0.1 HR>1" | filtered.plotting.data$status=="p<0.1 HR<1"),]
  light.red.cells <- filtered.plotting.data[which(filtered.plotting.data$status=="p<0.05 HR>1"),]
  dark.red.cells <- filtered.plotting.data[which(filtered.plotting.data$status=="p<0.01 HR>1"),]
  light.blue.cells <- filtered.plotting.data[which(filtered.plotting.data$status=="p<0.05 HR<1"),]
  dark.blue.cells <- filtered.plotting.data[which(filtered.plotting.data$status=="p<0.01 HR<1"),]
  to.plot <- rbind(light.grey.cells, dark.grey.cells, 
                         light.red.cells, light.blue.cells, 
                         dark.red.cells, dark.blue.cells)
  
  #plot
  filtered_VRPTR_plot <- ggplot(to.plot) + geom_point(aes(x=to.plot[,1], 
                                                              y=to.plot[,2], 
                                                     col = as.factor(to.plot$status))) + 
                        scale_color_manual(values = col.palette) + 
                        guides(colour = guide_legend(override.aes = list(size=5))) + 
                        theme_bw() + theme(panel.grid.major = element_blank(), 
                                           panel.grid.minor = element_blank()) + 
                        labs(color = "Prognostic Subsets", x = "t-SNE2", y = "t-SNE1", 
                             title = paste("Filtered VRPTR Prognostic Populations, k=", kval)) +
                        ylim(-max_y,max_y) +xlim(-max_x,max_x) + coord_fixed(ratio = 1)
  # filtered_VRPTR_plot

  #export
  png(paste0(output.path, '/filtered/', strftime(Sys.time(),"%Y-%m-%d"), " filtered_VRPTR_plot.png"),
      res = 200, width = 1500, height = 1500)
  print(filtered_VRPTR_plot)
  dev.off()

  
  
  
  #patient level survival plots
  #GNP
  #calculate GNP status
  GNP.clusters <- as.data.frame(all.subset.abundances[,as.character(unique(filtered.data[which(filtered.data$status=="p<0.01 HR>1" | filtered.data$status=="p<0.05 HR>1"),'cluster']))])
  GNP.clusters$sum <- rowSums(GNP.clusters)
  GNP.abundance.IQR <- IQR(GNP.clusters$sum)
  GNP.clusters$group <- ifelse(GNP.clusters$sum>=GNP.abundance.IQR, -1, 0)
  Group <- factor(GNP.clusters$group, levels = c(-1, 0), labels = c("GNP-High", "GNP-Low"))
  factored.data <- cbind(OS.data, Group) #select OS Time, OS Status and Group
  
  #calculate cox proportional hazards model 
  model.to.plot <- survfit(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=factored.data) #graphing data
  model.for.stats <- coxph(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=factored.data) #Cox PH Model
  model.stats <- summary(model.for.stats) #summarize cox ph
  
  #access interesting stats from Cox PH Model
  pval <- round(model.stats[["coefficients"]][,'Pr(>|z|)'], 3)
  HR <- round(1/model.stats[["coefficients"]][,'exp(coef)'], 3)
  CI <- paste0('[', round(1/model.stats[["conf.int"]][,4], 2), ',', 
               round(1/model.stats[["conf.int"]][,3], 2), ']')
  
  #plot
  GNP.plot <- ggsurvplot(model.to.plot, data=factored.data, risk.table=T,
                         legend.labs = c("GNP-high", "GNP-Low"), legend.title = "Group",
                         censor.shape=124, palette=c('darkred','black'))
  GNP.plot$plot <- GNP.plot$plot + annotate("text", x=Inf, y=Inf, vjust=1, hjust=1, size=5,
                                            label=paste0('p-value = ', pval, '
                                                         HR = ', HR, '
                                                         95% CI ', CI)) #annotate with stats
  # GNP.plot

  #export
  png(paste0(output.path, '/filtered/', strftime(Sys.time(),"%Y-%m-%d"), ' FILTERED_GNP survival plot.png'), height=1000, width=1000, res=200)
  print(GNP.plot)
  dev.off()
  write.csv(GNP.clusters, paste0(output.path, '/filtered/', strftime(Sys.time(),"%Y-%m-%d"), ' filtered GNP Classification.csv'))

  #GPP
  #calculate GPP status
  GPP.clusters <- as.data.frame(all.subset.abundances[,as.character(unique(filtered.data[which(filtered.data$status=="p<0.01 HR<1" | filtered.data$status=="p<0.05 HR<1"),'cluster']))])
  GPP.clusters$sum <- rowSums(GPP.clusters)
  GPP.abundance.IQR <- IQR(GPP.clusters$sum)
  GPP.clusters$group <- ifelse(GPP.clusters$sum>=GPP.abundance.IQR, 1, 0)
  Group <- factor(GPP.clusters$group, levels = c(0, 1), labels = c("GPP-Low", "GPP-High"))
  factored.data <- cbind(OS.data, Group) #select OS Time, OS Status and Group
  
  #calculate cox proportional hazards model 
  model.to.plot <- survfit(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=factored.data) #graphing data
  model.for.stats <- coxph(Surv(OS.data[,clinical_col], OS.data[,status_col]) ~ Group, data=factored.data) #Cox PH Model
  model.stats <- summary(model.for.stats) #summarize cox ph
  
  #access interesting stats from Cox PH Model
  pval <- round(model.stats[["coefficients"]][,'Pr(>|z|)'], 3)
  HR <- round(model.stats[["coefficients"]][,'exp(coef)'], 3)
  CI <- paste0('[', round(model.stats[["conf.int"]][,3], 2), ',', 
               round(model.stats[["conf.int"]][,4], 2), ']')

  #plot
  GPP.plot <- ggsurvplot(model.to.plot, data=factored.data, risk.table=T,
                         legend.labs = c("GPP-Low", "GPP-High"), legend.title = "Group",
                         censor.shape=124, palette=c('black','darkblue'))
  GPP.plot$plot <- GPP.plot$plot + annotate("text", x=Inf, y=Inf, vjust=1, hjust=1, size=5,
                                            label=paste0('p-value = ', pval, '
                                                         HR = ', HR, '
                                                         95% CI ', CI)) #annotate with stats
  # GPP.plot

  #export
  png(paste0(output.path, '/filtered/', strftime(Sys.time(),"%Y-%m-%d"), ' FILTERED_GPP survival plot.png'), height=1000, width=1000, res=200)
  print(GPP.plot)
  dev.off()
  write.csv(GPP.clusters, paste0(output.path, '/filtered/', strftime(Sys.time(),"%Y-%m-%d"), ' filtered GPP Classification.csv'))
  
  
  
  
  
  #MEM on combined GNP GPP populations
  setwd(paste0(output.path,'/filtered/'))

  #create variable for markers to use in MEM
  GNP.cells <- filtered.data[which(filtered.data$cluster %in% colnames(GNP.clusters)), 
                             c(4, 6, 8:9, 13, 15, 17:18, 20:21, 23:26, 28:37, 39, ncol(filtered.data))]
  GNP.cells$cluster <- -1
  GPP.cells <- filtered.data[which(filtered.data$cluster %in% colnames(GPP.clusters)), 
                             c(4, 6, 8:9, 13, 15, 17:18, 20:21, 23:26, 28:37, 39, ncol(filtered.data))]
  GPP.cells$cluster <- 1
  MEM.data <- rbind(GNP.cells, GPP.cells)
  colnames(MEM.data)[ncol(MEM.data)] <- "cluster"
  MEM.data$cluster <- as.numeric(as.character(MEM.data$cluster))
  MEM.data <- MEM.data[order(MEM.data$cluster),]

  #calculate MEM scores
  MEM.values <- MEM(MEM.data, transform = TRUE, cofactor = 5,
                    zero.ref = TRUE, new.marker.names = "CyclinB1, TUJ1, CD117, S100B, CD34, pSTAT5, pAKT, pSTAT1, CD56, pp38, pSTAT3, CD49F, CD133, PDGFRA, SOX2, CD15, EGFR, pNFkB, CD171, Nestin, CD44, GFAP, pERK, pS6, HLADR")
  # build MEM heatmap and output enrichment scores
  build_heatmaps(MEM.values, display.thresh = 1, output.files = TRUE,
                 cluster.MEM = "none", cluster.medians = "none", cluster.IQRs = "none")
  setwd(og.wd)
  
  #check time
  total_time <- Sys.time() - start_time
  time_diff <- paste(total_time, attr(total_time, 'units')) 
  print(time_diff)
  write.table(time_diff, file=paste0(output.path, '/time elapsed for results_k=', kval, '.txt'))
}
```

